name: Deploy VS Demo

on:
  workflow_dispatch:
    inputs:
      step:
        description: "Which step to run"
        required: true
        type: choice
        options:
          - deploy
          - setup-part1
          - setup-part2
          - all
        default: all

jobs:
  deploy-vs:
    name: Deploy and configure VS Agent
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate branch and extract network
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          if [[ ! "$BRANCH" =~ ^vs/(testnet|devnet)- ]]; then
            echo "::error::Branch must match vs/testnet-<name> or vs/devnet-<name> (current: $BRANCH)"
            exit 1
          fi
          # Extract network and service name from branch: vs/testnet-my-service
          SUFFIX="${BRANCH#vs/}"
          NETWORK="${SUFFIX%%-*}"
          VS_NAME="${SUFFIX#*-}"
          echo "NETWORK=${NETWORK}" >> "$GITHUB_ENV"
          echo "VS_NAME=${VS_NAME}" >> "$GITHUB_ENV"
          echo "Branch: $BRANCH — Network: $NETWORK — Service: $VS_NAME"

      - name: Load configuration
        run: |
          # Source config.env into GITHUB_ENV
          set -a
          source vs/config.env
          set +a
          # Export all variables to GITHUB_ENV
          while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^#.*$ ]] && continue
            [[ -z "$key" ]] && continue
            echo "${key}=${value}" >> "$GITHUB_ENV"
          done < <(grep -E '^[A-Z_]+=' vs/config.env)

      - name: Resolve deployment.yaml placeholders
        run: |
          # Substitute __NETWORK__ and __VS_NAME__ with values from branch name
          sed -e "s/__NETWORK__/${NETWORK}/g" -e "s/__VS_NAME__/${VS_NAME}/g" vs/deployment.yaml > /tmp/deployment-resolved.yaml
          echo "--- Resolved deployment.yaml ---"
          cat /tmp/deployment-resolved.yaml

      - name: Parse deployment.yaml
        run: |
          # Extract Helm metadata from resolved deployment.yaml
          CHART_SOURCE=$(yq '.chartSource' /tmp/deployment-resolved.yaml)
          CHART_VERSION=$(yq '.chartVersion' /tmp/deployment-resolved.yaml)
          CHART_NAMESPACE=$(yq '.chartNamespace' /tmp/deployment-resolved.yaml)
          RELEASE_NAME=$(yq '.name' /tmp/deployment-resolved.yaml)
          INGRESS_HOST=$(yq '.ingress.host' /tmp/deployment-resolved.yaml)
          echo "CHART_SOURCE=${CHART_SOURCE}" >> "$GITHUB_ENV"
          echo "CHART_VERSION=${CHART_VERSION}" >> "$GITHUB_ENV"
          echo "CHART_NAMESPACE=${CHART_NAMESPACE}" >> "$GITHUB_ENV"
          echo "RELEASE_NAME=${RELEASE_NAME}" >> "$GITHUB_ENV"
          echo "INGRESS_HOST=${INGRESS_HOST}" >> "$GITHUB_ENV"
          echo "Chart: $CHART_SOURCE@$CHART_VERSION → $CHART_NAMESPACE/$RELEASE_NAME"

      - name: Generate Helm values
        run: |
          # Strip Helm metadata fields, keep only chart values
          yq 'del(.chartSource, .chartVersion, .chartNamespace)' /tmp/deployment-resolved.yaml > /tmp/helm-values.yaml
          # Inject didcommLabel and didcommInvitationImageUrl from config.env
          # (using yq instead of --set to avoid YAML parse errors with spaces)
          yq -i '.didcommLabel = env(SERVICE_NAME)' /tmp/helm-values.yaml
          yq -i '.didcommInvitationImageUrl = env(SERVICE_LOGO_URL)' /tmp/helm-values.yaml
          echo "--- Helm values ---"
          cat /tmp/helm-values.yaml

      - name: Set up kubeconfig
        run: |
          mkdir -p ~/.kube
          cat > ~/.kube/config <<'KUBEEOF'
          ${{ secrets.OVH_KUBECONFIG }}
          KUBEEOF

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.29.9'

      - name: Install veranad
        run: |
          VERANAD_VERSION="v0.9.4"
          curl -sfL "https://github.com/verana-labs/verana/releases/download/${VERANAD_VERSION}/veranad-linux-amd64" \
            -o /usr/local/bin/veranad
          chmod +x /usr/local/bin/veranad
          veranad version

      - name: Import account from mnemonic
        run: |
          echo "${{ secrets.VS_DEMO_MNEMONIC }}" | veranad keys add "${{ env.USER_ACC }}" --recover --keyring-backend test

      # -----------------------------------------------------------------------
      # DEPLOY: Install/upgrade VS Agent via Helm
      # -----------------------------------------------------------------------
      - name: Deploy VS Agent via Helm
        if: inputs.step == 'deploy' || inputs.step == 'all'
        run: |
          helm upgrade --install "$RELEASE_NAME" "$CHART_SOURCE" \
            --version "$CHART_VERSION" \
            --namespace "$CHART_NAMESPACE" --create-namespace \
            --values /tmp/helm-values.yaml \
            --wait --timeout 300s

      # -----------------------------------------------------------------------
      # PORT-FORWARD: Access admin API via kubectl (same pattern as verana-deploy)
      # -----------------------------------------------------------------------
      - name: Port-forward VS Agent admin API
        if: inputs.step == 'setup-part1' || inputs.step == 'setup-part2' || inputs.step == 'all'
        run: |
          kubectl port-forward -n "$CHART_NAMESPACE" "svc/$RELEASE_NAME" 3000:3000 &
          echo "PF_PID=$!" >> "$GITHUB_ENV"
          sleep 5
          curl -sf http://localhost:3000/v1/agent > /dev/null || {
            echo "Port-forward failed — is the $RELEASE_NAME pod running in $CHART_NAMESPACE?"
            exit 1
          }
          echo "Port-forward established"

      # -----------------------------------------------------------------------
      # PART 1: Obtain ECS credentials (Organization + Service)
      # -----------------------------------------------------------------------
      - name: "Setup Part 1: Obtain ECS credentials"
        if: inputs.step == 'setup-part1' || inputs.step == 'all'
        run: |
          export ADMIN_API="http://localhost:3000"
          source scripts/vs-demo/common.sh
          set_network_vars "$NETWORK"

          # Get agent DID
          AGENT_INFO=$(curl -sf "${ADMIN_API}/v1/agent")
          AGENT_DID=$(echo "$AGENT_INFO" | jq -r '.publicDid')
          echo "AGENT_DID=${AGENT_DID}" >> "$GITHUB_ENV"
          ok "Agent DID: $AGENT_DID"

          # Discover Service schema ID from ECS TR DID document
          CS_SERVICE_ID=$(discover_ecs_schema_id "$ECS_TR_PUBLIC_URL" "service")
          echo "CS_SERVICE_ID=${CS_SERVICE_ID}" >> "$GITHUB_ENV"

          # Discover active root permission for Service schema
          ROOT_PERM_SERVICE=$(discover_active_root_perm "$CS_SERVICE_ID")

          # Clean up self-generated items
          cleanup_self_generated "$ADMIN_API"

          # Obtain Organization credential from ECS TR
          ORG_LOGO_B64=$(curl -sfL "$ORG_LOGO_URL" | base64 -w 0)
          SERVICE_LOGO_B64=$(curl -sfL "$SERVICE_LOGO_URL" | base64 -w 0)

          ORG_JSC_URL=$(curl -sf "${ECS_TR_ADMIN_API}/v1/vt/json-schema-credentials" \
            | jq -r '.data[] | select(.credential.type[]? == "VerifiableTrustJsonSchemaCredential") | select(.credential.credentialSubject.jsonSchema."$ref" | test("org")) | .credential.id' \
            | head -1)

          ORG_CLAIMS=$(jq -n \
            --arg id "$AGENT_DID" \
            --arg name "$ORG_NAME" \
            --arg logo "$ORG_LOGO_B64" \
            --arg rid "$ORG_REGISTRY_ID" \
            --arg addr "$ORG_ADDRESS" \
            --arg cc "$ORG_COUNTRY" \
            '{id: $id, name: $name, logo: $logo, registryId: $rid, address: $addr, countryCode: $cc}')

          issue_remote_and_link "$ECS_TR_ADMIN_API" "$ADMIN_API" "organization" "$ORG_JSC_URL" "$AGENT_DID" "$ORG_CLAIMS"

          # Self-create ISSUER permission for Service schema (OPEN mode)
          EFFECTIVE_FROM=$(future_timestamp 15)
          ISSUER_PERM_SERVICE=$(submit_tx "create_permission" "permission_id" \
            veranad tx perm create-perm "$CS_SERVICE_ID" issuer "$AGENT_DID" \
            --effective-from "$EFFECTIVE_FROM")
          sleep 21

          # Create Service VTJSC
          curl -sf -X POST "${ADMIN_API}/v1/vt/json-schema-credentials" \
            -H 'Content-Type: application/json' \
            -d "{\"schemaBaseId\": \"service\", \"jsonSchemaRef\": \"vpr:verana:${CHAIN_ID}/cs/v1/js/${CS_SERVICE_ID}\"}"

          # Self-issue Service credential
          SERVICE_CLAIMS=$(jq -n \
            --arg id "$AGENT_DID" \
            --arg name "$SERVICE_NAME" \
            --arg type "$SERVICE_TYPE" \
            --arg desc "$SERVICE_DESCRIPTION" \
            --arg logo "$SERVICE_LOGO_B64" \
            --argjson age "$SERVICE_MIN_AGE" \
            --arg terms "$SERVICE_TERMS" \
            --arg privacy "$SERVICE_PRIVACY" \
            '{id: $id, name: $name, type: $type, description: $desc, logo: $logo, minimumAgeRequired: $age, termsAndConditions: $terms, privacyPolicy: $privacy}')

          issue_and_link "$ADMIN_API" "service" "$CHAIN_ID" "$CS_SERVICE_ID" "$AGENT_DID" "$SERVICE_CLAIMS"

      # -----------------------------------------------------------------------
      # PART 2: Create Trust Registry with custom schema
      # -----------------------------------------------------------------------
      - name: "Setup Part 2: Create Trust Registry"
        if: inputs.step == 'setup-part2' || inputs.step == 'all'
        run: |
          export ADMIN_API="http://localhost:3000"
          source scripts/vs-demo/common.sh
          set_network_vars "$NETWORK"

          # Get agent DID (may already be in GITHUB_ENV from Part 1)
          if [ -z "${AGENT_DID:-}" ]; then
            AGENT_DID=$(curl -sf "${ADMIN_API}/v1/agent" | jq -r '.publicDid')
          fi

          # Compute EGF digest
          EGF_DOC_DIGEST=$(compute_sri_digest "$EGF_DOC_URL")
          ok "EGF digest: $EGF_DOC_DIGEST"

          # Derive registry URL from ingress host
          TR_REGISTRY_URL="https://${INGRESS_HOST}"

          # Create Trust Registry
          TRUST_REG_ID=$(submit_tx "create_trust_registry" "trust_registry_id" \
            veranad tx tr create-trust-registry \
            "$AGENT_DID" "en" "$EGF_DOC_URL" "$EGF_DOC_DIGEST" \
            --aka "$TR_REGISTRY_URL")

          # Create credential schema from vs/schema.json
          if [ -n "${CUSTOM_SCHEMA_URL:-}" ]; then
            SCHEMA_JSON=$(download_schema "$CUSTOM_SCHEMA_URL")
          else
            SCHEMA_JSON=$(jq -c '.' vs/schema.json)
          fi

          CUSTOM_SCHEMA_ID=$(submit_tx "create_credential_schema" "credential_schema_id" \
            veranad tx cs create-credential-schema "$TRUST_REG_ID" "$SCHEMA_JSON" \
            --issuer-grantor-validation-validity-period '{"value":0}' \
            --verifier-grantor-validation-validity-period '{"value":0}' \
            --issuer-validation-validity-period '{"value":0}' \
            --verifier-validation-validity-period '{"value":0}' \
            --holder-validation-validity-period '{"value":0}' \
            3 1)

          # Create root permission
          EFFECTIVE_FROM=$(future_timestamp 15)
          ROOT_PERM_ID=$(submit_tx "create_root_permission" "root_permission_id" \
            veranad tx perm create-root-perm \
            "$CUSTOM_SCHEMA_ID" "$AGENT_DID" 0 0 0 \
            --effective-from "$EFFECTIVE_FROM")
          sleep 21

          # Obtain ISSUER permission via VP flow
          START_RESULT=$(veranad tx perm start-perm-vp \
            issuer "$ROOT_PERM_ID" --did "$AGENT_DID" \
            --from "$USER_ACC" --chain-id "$CHAIN_ID" --keyring-backend test \
            --fees "$FEES" --gas auto --node "$NODE_RPC" \
            --output json -y 2>&1 | extract_tx_json)
          START_TX_HASH=$(echo "$START_RESULT" | jq -r '.txhash')
          sleep 8
          ISSUER_PERM_ID=$(extract_tx_event "$START_TX_HASH" "start_permission_vp" "permission_id")

          veranad tx perm set-perm-vp-validated "$ISSUER_PERM_ID" \
            --from "$USER_ACC" --chain-id "$CHAIN_ID" --keyring-backend test \
            --fees "$FEES" --gas auto --node "$NODE_RPC" \
            --output json -y 2>&1
          sleep 6

          # Create VTJSC
          curl -sf -X POST "${ADMIN_API}/v1/vt/json-schema-credentials" \
            -H 'Content-Type: application/json' \
            -d "{\"schemaBaseId\": \"${CUSTOM_SCHEMA_BASE_ID}\", \"jsonSchemaRef\": \"vpr:verana:${CHAIN_ID}/cs/v1/js/${CUSTOM_SCHEMA_ID}\"}"

          # Optional: AnonCreds
          if [ "$ENABLE_ANONCREDS" = "true" ]; then
            VTJSC_VPR_REF="vpr:verana:${CHAIN_ID}/cs/v1/js/${CUSTOM_SCHEMA_ID}"
            VTJSC_CRED_ID=$(curl -sf "${ADMIN_API}/v1/vt/json-schema-credentials" \
              | jq -r --arg sid "$VTJSC_VPR_REF" '.data[] | select(.schemaId == $sid) | .credential.id')
            curl -sf -X POST "${ADMIN_API}/v1/credential-types" \
              -H 'Content-Type: application/json' \
              -d "{\"name\": \"${CUSTOM_SCHEMA_BASE_ID}\", \"version\": \"1.0\", \"relatedJsonSchemaCredentialId\": \"${VTJSC_CRED_ID}\", \"supportRevocation\": false}"
          fi

          echo "Trust Registry setup complete: TR=$TRUST_REG_ID Schema=$CUSTOM_SCHEMA_ID"

      # -----------------------------------------------------------------------
      # CLEANUP
      # -----------------------------------------------------------------------
      - name: Cleanup port-forward
        if: always()
        run: |
          kill ${{ env.PF_PID }} 2>/dev/null || true
